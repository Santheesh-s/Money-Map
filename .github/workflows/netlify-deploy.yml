name: Build & Deploy Money-Map to Netlify (CI-only edits)

on:
  push:
    branches: [ main ]

env:
  NODE_VERSION: 18
  # Set to "true" to stub OCR endpoints in CI (if your project uses native binaries)
  STUB_OCR: "false"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: money-map-netlify-deploy
      cancel-in-progress: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Build frontend (if present)
        run: |
          set -e
          if [ -d frontend ] && [ -f frontend/package.json ]; then
            echo "Building frontend..."
            cd frontend
            npm ci
            npm run build
            cd -
          else
            echo "No frontend build to run."
          fi

      - name: Prepare out/ and copy backend + frontend build
        run: |
          set -e
          rm -rf out
          mkdir -p out/publish out/functions out/backend

          if [ -d frontend/build ]; then
            cp -r frontend/build/* out/publish/ || true
            echo "Copied frontend/build -> out/publish"
          elif [ -d frontend/dist ]; then
            cp -r frontend/dist/* out/publish/ || true
            echo "Copied frontend/dist -> out/publish"
          else
            echo "No frontend build found"
          fi

          if [ -d backend ]; then
            cp -r backend/* out/backend/
            echo "Copied backend -> out/backend"
          else
            echo "ERROR: backend folder not found" >&2
            exit 1
          fi

      - name: Detect backend entry file
        id: detect-entry
        run: |
          set -e
          CANDIDATES="app.js index.js server.js src/index.js src/app.js"
          ENTRY=""
          for f in $CANDIDATES; do
            if [ -f "out/backend/$f" ]; then
              ENTRY="$f"
              break
            fi
          done
          if [ -z "$ENTRY" ]; then
            ENTRY="server.js"
          fi
          echo "Detected entry: $ENTRY"
          echo "::set-output name=entry::$ENTRY"

      - name: Patch copied backend to be serverless-safe (sed-based, no heredoc)
        env:
          ENTRY: ${{ steps.detect-entry.outputs.entry }}
          STUB_OCR: ${{ env.STUB_OCR }}
        run: |
          set -e
          ENTRY_PATH="out/backend/$ENTRY"
          echo "Patching $ENTRY_PATH"

          if [ ! -f "$ENTRY_PATH" ]; then
            echo "Entry file not found: $ENTRY_PATH" >&2
            exit 1
          fi

          # 1) Remove lines that call scheduleBudgetChecks(...) (simple heuristic)
          if grep -q "scheduleBudgetChecks" "$ENTRY_PATH"; then
            echo "Removing scheduleBudgetChecks() calls"
            # delete lines that contain scheduleBudgetChecks(...)
            sed -i.bak '/scheduleBudgetChecks\s*(/I d' "$ENTRY_PATH" || true
          else
            echo "No scheduleBudgetChecks occurrences found"
          fi

          # 2) Remove app.listen(...) occurrences (basic removal)
          if grep -qi "app.listen" "$ENTRY_PATH"; then
            echo "Removing app.listen(...) occurrences"
            # remove lines containing app.listen( ... );
            # this is a simple heuristic; remove lines with 'app.listen'
            sed -i.bak '/app\.listen\s*(/I d' "$ENTRY_PATH" || true
          else
            echo "No app.listen occurrences found"
          fi

          # 3) Ensure module.exports = app exists (append if missing)
          if ! grep -q "module\\.exports\\s*=\\s*app" "$ENTRY_PATH"; then
            echo -e "\n// CI appended: export app for serverless wrapper\ntry { if (typeof module !== 'undefined') module.exports = app; } catch(e) {}" >> "$ENTRY_PATH"
            echo "App export appended."
          else
            echo "module.exports = app already present."
          fi

          # 4) Append require.main guard at EOF that runs schedule/listen when run directly
          # We'll append guarded calls that attempt to call scheduleBudgetChecks() and start the listener
          cat >> "$ENTRY_PATH" <<'EOF'

// CI appended: start server and background jobs only when run directly
try {
  if (require.main === module) {
    // Call scheduleBudgetChecks if present
    try { if (typeof scheduleBudgetChecks === 'function') scheduleBudgetChecks(); } catch(e) { /* ignore */ }

    // Start server with default port if app is set and not already listening
    try {
      const port = process.env.PORT || 3000;
      if (app && app.listen) {
        app.listen(port, () => { console.log('Server started (CI guard) on port', port); });
      }
    } catch(e) { /* ignore */ }
  }
} catch(e) { /* ignore */ }

EOF

          echo "Appended require.main guard to $ENTRY_PATH"

          # 5) Optionally stub OCR/native endpoints if STUB_OCR=true
          if [ "${STUB_OCR}" = "true" ]; then
            echo "STUB_OCR=true: adding OCR stub endpoints to out/backend"
            cat >> "$ENTRY_PATH" <<'EOF'

// CI appended: stub OCR endpoints (native binaries not available in Netlify functions)
try {
  if (app && app.post) {
    try { app.post('/api/uploadPdf', (req, res) => res.status(501).json({ error: 'OCR disabled in serverless deploy' })); } catch(e) {}
    try { app.post('/api/ocr', (req, res) => res.status(501).json({ error: 'OCR disabled in serverless deploy' })); } catch(e) {}
  }
} catch(e) {}
EOF
            echo "OCR stubs appended."
          fi

      - name: Create functions wrapper (serverless-http)
        env:
          ENTRY: ${{ steps.detect-entry.outputs.entry }}
        run: |
          set -e
          # create wrapper that requires out/backend/<entry> (without .js extension)
          REQ=$(echo "out/backend/${ENTRY}" | sed 's|^out/||' | sed 's|\.js$||')
          mkdir -p out/functions
          echo "const serverless = require('serverless-http');" > out/functions/server.js
          echo "let app = require('../${REQ}');" >> out/functions/server.js
          echo "if (typeof app === 'function' && !app.use) app = app();" >> out/functions/server.js
          echo "module.exports.handler = serverless(app);" >> out/functions/server.js
          echo "Created out/functions/server.js"

      - name: Build merged out/package.json from backend/package.json
        run: |
          set -e
          # create out/package.json merging backend dependencies; fallback to empty deps if none
          node -e "
const fs=require('fs');
const path=require('path');
const outPkg={
  name:'money-map-netlify-out',
  private:true,
  version:'1.0.0',
  engines:{node:'18.x'},
  dependencies:{},
  devDependencies:{}
};
const backendPkgPath=path.join('out','backend','package.json');
if (fs.existsSync(backendPkgPath)) {
  try {
    const backendPkg=JSON.parse(fs.readFileSync(backendPkgPath,'utf8'));
    if (backendPkg.dependencies) Object.assign(outPkg.dependencies, backendPkg.dependencies);
    if (backendPkg.devDependencies) Object.assign(outPkg.devDependencies, backendPkg.devDependencies);
  } catch(e){ console.warn('Failed to parse backend package.json', e.message); }
}
outPkg.dependencies['serverless-http']='^3.0.0';
fs.writeFileSync('out/package.json', JSON.stringify(outPkg,null,2));
console.log('Wrote out/package.json');"

      - name: Install dependencies in out/
        run: |
          set -e
          cd out
          if [ -f package-lock.json ]; then
            npm ci --no-audit --progress=false
          else
            npm install --production --no-audit --progress=false
          fi

      - name: Install netlify-cli
        run: |
          npm install -g netlify-cli

      - name: Deploy to Netlify (publish + functions)
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          set -e
          if [ ! -d out/publish ]; then mkdir -p out/publish; fi
          netlify deploy \
            --site "$NETLIFY_SITE_ID" \
            --auth "$NETLIFY_AUTH_TOKEN" \
            --dir out/publish \
            --functions out/functions \
            --prod
