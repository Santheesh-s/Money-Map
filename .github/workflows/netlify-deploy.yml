name: Deploy backend to Netlify Functions (CI-only edits)

on:
  push:
    branches: [ main ]

env:
  NODE_VERSION: 18
  # If your backend uses native binaries (pdf-poppler, tesseract), set STUB_OCR to "true"
  STUB_OCR: "false"

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    concurrency:
      group: money-map-netlify-backend
      cancel-in-progress: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Prepare out/ and copy backend
        run: |
          set -e
          rm -rf out
          mkdir -p out/functions out/backend out/publish
          # copy entire backend into out/backend (CI-only edits will modify this copy)
          if [ -d backend ]; then
            cp -r backend/* out/backend/
            echo "Copied backend -> out/backend"
          else
            echo "ERROR: backend folder not found" >&2
            exit 1
          fi
          # ensure publish exists (Netlify CLI requires --dir)
          mkdir -p out/publish

      - name: Detect backend entry file
        id: detect-entry
        run: |
          set -e
          CANDIDATES="app.js index.js server.js src/index.js src/app.js"
          ENTRY=""
          for f in $CANDIDATES; do
            if [ -f "out/backend/$f" ]; then
              ENTRY="$f"
              break
            fi
          done
          if [ -z "$ENTRY" ]; then
            ENTRY="server.js"
          fi
          echo "entry=$ENTRY" >> "$GITHUB_OUTPUT"

      - name: Patch copied backend to be serverless-safe (no heredocs)
        env:
          ENTRY: ${{ steps.detect-entry.outputs.entry }}
          STUB_OCR: ${{ env.STUB_OCR }}
        run: |
          set -e
          ENTRY_PATH="out/backend/${ENTRY}"
          echo "Patching ${ENTRY_PATH}"

          if [ ! -f "${ENTRY_PATH}" ]; then
            echo "Entry file not found: ${ENTRY_PATH}" >&2
            exit 1
          fi

          # Remove scheduleBudgetChecks(...) lines if present
          if grep -qi "scheduleBudgetChecks" "${ENTRY_PATH}"; then
            echo "Removing scheduleBudgetChecks() lines"
            sed -i.bak '/scheduleBudgetChecks\s*(/I d' "${ENTRY_PATH}" || true
          fi

          # Remove app.listen(...) occurrences
          if grep -qi "app.listen" "${ENTRY_PATH}"; then
            echo "Removing app.listen(...) lines"
            sed -i.bak '/app\.listen\s*(/I d' "${ENTRY_PATH}" || true
          fi

          # Append module.exports = app if missing
          if ! grep -q "module\\.exports\\s*=\\s*app" "${ENTRY_PATH}"; then
            printf "\n// CI appended: export app for serverless wrapper\ntry { if (typeof module !== 'undefined') module.exports = app; } catch(e) {}\n" >> "${ENTRY_PATH}"
            echo "App export appended."
          fi

          # Append require.main guard at EOF to run schedule/listen when run directly
          printf "\n// CI appended: start server and background jobs only when run directly\ntry {\n  if (require.main === module) {\n    try { if (typeof scheduleBudgetChecks === 'function') scheduleBudgetChecks(); } catch(e) {}\n    try {\n      const port = process.env.PORT || 3000;\n      if (app && app.listen) {\n        app.listen(port, () => { console.log('Server started (CI guard) on port', port); });\n      }\n    } catch(e) {}\n  }\n} catch(e) {}\n" >> "${ENTRY_PATH}"
          echo "Appended require.main guard to ${ENTRY_PATH}"

          # Optionally stub OCR/native endpoints
          if [ "${STUB_OCR}" = "true" ]; then
            printf "\n// CI appended: stub OCR endpoints (native binaries not available)\ntry {\n  if (app && app.post) {\n    try { app.post('/api/uploadPdf', (req, res) => res.status(501).json({ error: 'OCR disabled in serverless deploy' })); } catch(e) {}\n    try { app.post('/api/ocr', (req, res) => res.status(501).json({ error: 'OCR disabled in serverless deploy' })); } catch(e) {}\n  }\n} catch(e) {}\n" >> "${ENTRY_PATH}"
            echo "OCR stubs appended."
          fi

      - name: Create functions wrapper (serverless-http)
        env:
          ENTRY: ${{ steps.detect-entry.outputs.entry }}
        run: |
          set -e
          REQ=$(echo "out/backend/${ENTRY}" | sed 's|^out/||' | sed 's|\.js$||')
          mkdir -p out/functions
          echo "const serverless = require('serverless-http');" > out/functions/server.js
          echo "let app = require('../${REQ}');" >> out/functions/server.js
          echo "if (typeof app === 'function' && !app.use) app = app();" >> out/functions/server.js
          echo "module.exports.handler = serverless(app);" >> out/functions/server.js
          echo "Created out/functions/server.js requiring ../${REQ}"

      - name: Create out/package.json merging backend deps
        run: |
          set -e
          node -e "const fs=require('fs'),path=require('path');const outPkg={name:'money-map-netlify-out',private:true,version:'1.0.0',engines:{node:'18.x'},dependencies:{},devDependencies:{}};const bp=path.join('out','backend','package.json');if(fs.existsSync(bp)){try{const b=JSON.parse(fs.readFileSync(bp,'utf8'));if(b.dependencies)Object.assign(outPkg.dependencies,b.dependencies);if(b.devDependencies)Object.assign(outPkg.devDependencies,b.devDependencies);}catch(e){console.warn('parse backend package.json failed',e.message);} } outPkg.dependencies['serverless-http']='^3.0.0';fs.writeFileSync(path.join('out','package.json'),JSON.stringify(outPkg,null,2));console.log('Wrote out/package.json');"

      - name: Install dependencies in out/
        run: |
          set -e
          cd out
          if [ -f package-lock.json ]; then
            npm ci --no-audit --progress=false
          else
            npm install --production --no-audit --progress=false
          fi

      - name: Install netlify-cli (global)
        run: |
          npm install -g netlify-cli

      - name: Deploy functions to Netlify
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          set -e
          # ensure publish exists (Netlify CLI requires dir)
          if [ ! -d out/publish ]; then mkdir -p out/publish; fi
          netlify deploy \
            --site "$NETLIFY_SITE_ID" \
            --auth "$NETLIFY_AUTH_TOKEN" \
            --dir out/publish \
            --functions out/functions \
            --prod
            
